diff --git a/plugins/producer_plugin/producer_plugin.cpp b/plugins/producer_plugin/producer_plugin.cpp
index dc650e5cf..b097927be 100644
--- a/plugins/producer_plugin/producer_plugin.cpp
+++ b/plugins/producer_plugin/producer_plugin.cpp
@@ -1743,6 +1743,8 @@ bool producer_plugin_impl::process_unapplied_trxs( const fc::time_point& deadlin
 {
    bool exhausted = false;
    if( !_unapplied_transactions.empty() ) {
+      constexpr uint32_t max_failures_per_account = 3;
+      std::map<account_name, uint32_t> account_failures;
       chain::controller& chain = chain_plug->chain();
       int num_applied = 0, num_failed = 0, num_processed = 0;
       auto unapplied_trxs_size = _unapplied_transactions.size();
@@ -1761,11 +1763,18 @@ bool producer_plugin_impl::process_unapplied_trxs( const fc::time_point& deadlin
          try {
             auto start = fc::time_point::now();
             auto trx_deadline = start + fc::milliseconds( _max_transaction_time_ms );
+            auto fitr = account_failures.find( trx->packed_trx()->get_transaction().first_authorizer() );
+            if( fitr != account_failures.end() && fitr->second >= max_failures_per_account ) {
+               ++fitr->second;
+               ++num_failed;
+               itr = _unapplied_transactions.erase( itr );
+               continue;
+            }
 
             auto prev_billed_cpu_time_us = trx->billed_cpu_time_us;
             if( prev_billed_cpu_time_us > 0 ) {
-               auto prev_billed_plus50 = prev_billed_cpu_time_us + EOS_PERCENT( prev_billed_cpu_time_us, 50 * config::percent_1 );
-               auto trx_dl = start + fc::microseconds( prev_billed_plus50 );
+               auto prev_billed_plus100 = prev_billed_cpu_time_us + EOS_PERCENT( prev_billed_cpu_time_us, 100 * config::percent_1 );
+               auto trx_dl = start + fc::microseconds( prev_billed_plus100 );
                if( trx_dl < trx_deadline ) trx_deadline = trx_dl;
             }
             bool deadline_is_subjective = false;
@@ -1784,10 +1793,14 @@ bool producer_plugin_impl::process_unapplied_trxs( const fc::time_point& deadlin
                      break;
                   }
                } else {
+                  auto failure_code = trace->except->code();
                   // this failed our configured maximum transaction time, we don't want to replay it
                   fc_dlog( _log, "Failed ${c} trx, prev billed: ${p}us, ran: ${r}us, id: ${id}",
                            ("c", trace->except->code())("p", prev_billed_cpu_time_us)
                            ("r", fc::time_point::now() - start)("id", trx->id()) );
+                  if( failure_code == deadline_exception::code_value || failure_code == tx_cpu_usage_exceeded::code_value ) {
+                     ++account_failures[trx->packed_trx()->get_transaction().first_authorizer()];
+                  }
                   ++num_failed;
                   itr = _unapplied_transactions.erase( itr );
                   continue;
@@ -1803,6 +1816,11 @@ bool producer_plugin_impl::process_unapplied_trxs( const fc::time_point& deadlin
 
       fc_dlog( _log, "Processed ${m} of ${n} previously applied transactions, Applied ${applied}, Failed/Dropped ${failed}",
                ("m", num_processed)( "n", unapplied_trxs_size )("applied", num_applied)("failed", num_failed) );
+      for( const auto& e : account_failures ) {
+         if( e.second > max_failures_per_account ) {
+            fc_dlog( _log, "Dropped ${n} trx of account: ${a}", ("n", e.second - max_failures_per_account)( "a", e.first ) );
+         }
+      }
    }
    return !exhausted;
 }
